<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Two dimensions · SemiLagrangian.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://juliavlasov.github.io/SemiLagrangian.jl/modele_2d/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SemiLagrangian.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SemiLagrangian.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quickstart/">Quickstart</a></li><li class="is-active"><a class="tocitem" href>Two dimensions</a><ul class="internal"><li><a class="tocitem" href="#General-context"><span>General context</span></a></li><li><a class="tocitem" href="#Details-on-the-2D-semi-Lagrangian-method"><span>Details on the <span>$2D$</span> semi-Lagrangian method</span></a></li><li><a class="tocitem" href="#ODE-solver"><span>ODE solver</span></a></li><li><a class="tocitem" href="#2D-Interpolation"><span><span>$2D$</span> Interpolation</span></a></li><li><a class="tocitem" href="#Some-examples"><span>Some examples</span></a></li><li><a class="tocitem" href="#Etienne&#39;s-models"><span>Etienne&#39;s models</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../functions/">Functions</a></li><li><a class="tocitem" href="../contents/">Contents</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Two dimensions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Two dimensions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaVlasov/SemiLagrangian.jl/blob/master/docs/src/modele_2d.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Two-dimensional-problems"><a class="docs-heading-anchor" href="#Two-dimensional-problems">Two-dimensional problems</a><a id="Two-dimensional-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Two-dimensional-problems" title="Permalink"></a></h1><p>In this document, we detail some aspects of the <span>$2$</span>-dimensional semi-Lagrangian method and give some examples to validate the implementation.</p><h2 id="General-context"><a class="docs-heading-anchor" href="#General-context">General context</a><a id="General-context-1"></a><a class="docs-heading-anchor-permalink" href="#General-context" title="Permalink"></a></h2><p>We consider <span>$2D$</span> transport equation of the form </p><p class="math-container">\[\tag{1}
\partial_t f + u_x \partial_x f + u_y \partial_y f = 0, f(t=0, x, y)= f_0(x, y), x, y\in \Omega\subset \mathbb{R}^2,\]</p><p>where the advection field <span>$(u_x, u_y)(t, x, y)$</span> satisfies the incompressibility condition <span>$\partial_x u_x + \partial_y u_y=0$</span> which implies (1) can be reformulated as</p><p class="math-container">\[\partial_t f + \partial_x( u_x  f )+ \partial_y(u_y  f) = 0, f(t=0, x, y)= f_0(x, y),\]</p><p>from which we deduce the mass conservation <span>$\int\!\!\int f(t, x, y) dxdy = \int\!\!\int f_0(x, y) dxdy$</span>. To solve numerically (1), we will use a <span>$2D$</span> semi-Lagrangian method which is based on the fact that the solution <span>$f$</span> is constant along the characteristics <span>$X(t)=(x(t), y(t))$</span> defined by</p><p class="math-container">\[\dot{X}(t) = U(t, X(t)), \;\; X(s) = X_g,\]</p><p>with <span>$U(t, X):=U(t, x, y)=(u_x(t, x, y), u_y(t, x, y))$</span>, <span>$s$</span> is a time and <span>$X_g$</span> is a prescribed condition (which will be a grid point). Hence, we can write <span>$f(s, X(s))=f(t, X(t))$</span> for all <span>$t, s$</span>. Considering a discretization of the time <span>$t^n=n\Delta t$</span> with <span>$n\in \mathbb{N}$</span> and <span>$\Delta t&gt;0$</span> the time step, we rewrite the latter equality with <span>$s=t^{n+1}$</span> and <span>$t=t^n$</span> to get </p><p class="math-container">\[f(t^{n+1}, X_g) = f(t^n, X(t^n)).\]</p><p>We want to compute the left hand side which corresponds to the numerical solution at time <span>$t^{n+1}$</span> and at the grid point <span>$X_g$</span>. To do so, we assume (by induction) that the solution is known at time <span>$t^n$</span> and at the grid points <span>$X_g$</span>, thus, we have to interpolate (in <span>$2D$</span>) to compute <span>$f(t^n, X(t^n))$</span>. The semi-Lagrangian methods can be split into two steps</p><ol><li><p>compute <span>$X(t^n)$</span></p></li><li><p>compute <span>$f(t^n, X(t^n))$</span>: from the known values <span>$f(t^n, X_g)$</span>,  interpolate at <span>$X(t^n)$</span>.</p></li></ol><p>These two steps are details in the next section.</p><h2 id="Details-on-the-2D-semi-Lagrangian-method"><a class="docs-heading-anchor" href="#Details-on-the-2D-semi-Lagrangian-method">Details on the <span>$2D$</span> semi-Lagrangian method</a><a id="Details-on-the-2D-semi-Lagrangian-method-1"></a><a class="docs-heading-anchor-permalink" href="#Details-on-the-2D-semi-Lagrangian-method" title="Permalink"></a></h2><p>The two steps of the semi-Lagrangian are detailed and some examples are given.</p><h2 id="ODE-solver"><a class="docs-heading-anchor" href="#ODE-solver">ODE solver</a><a id="ODE-solver-1"></a><a class="docs-heading-anchor-permalink" href="#ODE-solver" title="Permalink"></a></h2><p>First, we need to compute <span>$X(t^n)$</span> which the solution at time <span>$t^n$</span> of</p><p class="math-container">\[\tag{2}
\dot{X}(t) = U(t, X(t)), \;\; X(t^{n+1}) = X_g.\]</p><p>When <span>$U$</span> is simple enough, <span>$X(t^n)$</span> can be computed analytically but in general, we need a solver of this differential equation. The main difficulty comes from the fact that (2) has to be solved backward in time and when the time dependency of <span>$U$</span> is nonlinearly coupled to the solution <span>$f$</span> itself (see Examples 3 and 4 below), we do not know <span>$U(t, \dot)$</span> for <span>$t&gt;t^n$</span> (and time extrapolation has to be used <sup class="footnote-reference"><a id="citeref-filbet" href="#footnote-filbet">[filbet]</a></sup>).</p><h3 id="First-order"><a class="docs-heading-anchor" href="#First-order">First order</a><a id="First-order-1"></a><a class="docs-heading-anchor-permalink" href="#First-order" title="Permalink"></a></h3><p>A simple scheme to compute <span>$X(t^n)$</span> is the Euler scheme applied to (2)</p><p class="math-container">\[\frac{X(t^{n+1}) - X(t^n)}{\Delta t} = U(t^n, X(t^{n+1})),\]</p><p>and using the condition <span>$X(t^{n+1}) = X_g$</span>, we get the following first order approximation for <span>$X(t^n)$</span> </p><p class="math-container">\[X(t^n) = X_g - \Delta t U(t^n, X_g).\]</p><h3 id="Second-order"><a class="docs-heading-anchor" href="#Second-order">Second order</a><a id="Second-order-1"></a><a class="docs-heading-anchor-permalink" href="#Second-order" title="Permalink"></a></h3><p>A mid-point scheme (which is second order accurate) can be used to solve (2):</p><p class="math-container">\[\frac{X(t^{n+1}) - X(t^n)}{\Delta t} = U\Big(t^{n+1/2}, \frac{X(t^{n+1}) + X(t^n)}{2}\Big),\]</p><p>which gives an implicit expression for <span>$X(t^n)$</span> </p><p class="math-container">\[\begin{equation}
\label{ode_2nd_imp}
X(t^n) = X(t^{n+1}) -\Delta t \, U\Big(t^{n+1/2}, \frac{X(t^{n+1}) + X(t^n)}{2}\Big).
\end{equation}\]</p><p>As mentioned above, we first need to extrapolate <span>$U(t^{n+1/2}, \cdot)$</span>. To do so, we use <span>$U(t^{n-1}, \cdot)$</span> and <span>$U(t^{n}, \cdot)$</span> and we construct a first order Lagrange polynomial <span>${\cal L}(t), t\in[t^{n-1}, t^n]$</span></p><p class="math-container">\[{\cal L}(t) = U(t^n, \cdot) \frac{t^{n-1}-t}{\Delta t} + U(t^{n-1}, \cdot) \frac{t - t^{n}}{\Delta t}.\]</p><p>We then approximate <span>$U(t^{n+1/2}, \cdot)$</span> by <span>${\cal L}(t^{n+1/2})$</span>. We then have to solve \eqref{ode<em>2nd</em>imp} using a fixed point</p><p class="math-container">\[X^{n, k+1} = X_g -\Delta t \, {\cal L}\Big(t^{n+1/2}, \frac{X_g + X^{n,k}}{2}\Big), \;\; \mbox{ for } k\geq 0, X^{n, 0}=X_g,\]</p><p>up to convergence.</p><h3 id="Extension-to-higher-order"><a class="docs-heading-anchor" href="#Extension-to-higher-order">Extension to higher order</a><a id="Extension-to-higher-order-1"></a><a class="docs-heading-anchor-permalink" href="#Extension-to-higher-order" title="Permalink"></a></h3><p>We can look at the schemes proposed in <sup class="footnote-reference"><a id="citeref-filbet" href="#footnote-filbet">[filbet]</a></sup> but we can also use the package <code>DifferentialEquations.jl</code></p><h2 id="2D-Interpolation"><a class="docs-heading-anchor" href="#2D-Interpolation"><span>$2D$</span> Interpolation</a><a id="2D-Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#2D-Interpolation" title="Permalink"></a></h2><p>Once <span>$X(t^n)$</span> has been computed using the techniques detailed before, one has to compute <span>$f(t^n, X(t^n))$</span>. Since the grid values <span>$f(t^n, X_g)$</span> are known, we can reconstruct a piecewise <span>$2D$</span> polynomial function <span>${\cal P}(x, y), x, y\in \Omega$</span> using Lagrange or splines such that <span>$f(t^n, X_g) = {\cal P}(X_g)$</span>, and then we approximate <span>$f(t^n, X(t^n)) \approx {\cal P}(X(t^n)).$</span> We consider a cartesian grid of <span>$N_x\times N_y$</span> points <span>$x_i = (i-1)\Delta x$</span> and <span>$y_j =(j-1)\Delta y$</span> for <span>$i=1, \dots, N_x$</span> and <span>$j=1, \dots, N_y$</span>. We assume periodicity in <span>$x$</span> and <span>$y$</span> which means <span>$f(x_{N_x+1}, y) = f(x_1, y)$</span> and <span>$f(x, y_{N_y+1}) = f(x, y_1)$</span>.</p><h3 id="Lagrange-interpolation"><a class="docs-heading-anchor" href="#Lagrange-interpolation">Lagrange interpolation</a><a id="Lagrange-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrange-interpolation" title="Permalink"></a></h3><p>A tensor product can be done. If we denote <span>$L_{x,i}$</span> and <span>$L_{y,j}$</span> the Lagrange polynomial of degree <span>$2d+1$</span> in the <span>$x$</span> and <span>$y$</span> direction <span>$L_{x,i}(x) = \Pi_{k=i-d, k\neq i}^{i+d} \frac{(x-x_k)}{(x_i-x_k)}$</span> and <span>$L_{y,j}(x) = \Pi_{k=j-d, k\neq j}^{j+d} \frac{(y-y_k)}{(y_j-y_k)}$</span>. Then, we have</p><p class="math-container">\[f(x,y) \approx {\cal P}(x,y) =\sum_{i=1}^{N_x} \sum_{j=1}^{N_y} f(x_i,y_j) L_{x,i}(x)L_{y,j}(y).\]</p><h3 id="Splines-interpolation"><a class="docs-heading-anchor" href="#Splines-interpolation">Splines interpolation</a><a id="Splines-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Splines-interpolation" title="Permalink"></a></h3><p>For cubic splines, one can use</p><pre><code class="language-julia hljs">splinePP </code></pre><p>which I try to explain below.</p><p>We introduce the tridiagonal matrix <span>$A\in {\cal M}_{Nx+1, N_x+1}$</span> with <span>$4$</span> on the diagonal and <span>$1$</span> on the two extradiagonals. We consider <span>$f(x_i, y_j)$</span> for <span>$i=1, \dots, N_x$</span> and <span>$j=1, \dots, N_y$</span> and we denote <span>$F\in {\cal M}_{N_x+1, N_y}$</span> the matrix such that <span>$F_{i,j} = f(x_i,y_j)$</span> for <span>$i=1, \dots, N_x$</span> and <span>$j=1, \dots, N_y$</span> and <span>$F_{N_x+1, j}= f(x_1, y_j)$</span> for periodicity. We compute the splines coefficients as</p><ul><li><p>solve <span>$A \eta_j = 6 f(:,y_j), \;\; \forall j=1, \dots, N_y$</span> with <span>$\eta_j\in \mathbb{R}^{N_x+1}$</span></p></li><li><p>gestion du bord (Pierre ?) pour obtenir <span>$\eta(1:Nx+3, 1:N_y+1)$</span></p></li><li><p>solve <span>$A \,{\tt coef}_i \, = 6 \eta(i,:), \;\; \forall i=1, \cdots, N_x+3 $ with ${\tt coef}_i\in \mathbb{R}^{N_y+1}$</span></p></li><li><p>gestion du bord (Pierre ?) pour obtenir coef<span>$(1:Nx+3, 1:N_y+3)$</span></p></li></ul><p class="math-container">\[f(x,y) \approx {\cal S}(x,y) = \sum_i\sum_j {\tt coef}_{i,j} B_i(x) B_j(y)\]</p><h2 id="Some-examples"><a class="docs-heading-anchor" href="#Some-examples">Some examples</a><a id="Some-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Some-examples" title="Permalink"></a></h2><p>In this part, some examples of increasing difficulty are proposed to validate our algorithms.</p><h3 id="Example-1-:-rotation"><a class="docs-heading-anchor" href="#Example-1-:-rotation">Example 1 : rotation</a><a id="Example-1-:-rotation-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1-:-rotation" title="Permalink"></a></h3><p class="math-container">\[\partial_t f + y \partial_x f - x \partial_y f = 0, f(t=0, x, y)= f_0(x, y).\]</p><p>We already discussed this test and we have to check it again. In this case, the characteristics can be solved exactly in time since <span>$X(t^n) = e^{-J \Delta t}X_g$</span> with <span>$J$</span> the symplectic matrix. This test will enable us to validate the <span>$2D$</span> interpolation step. Here</p><p class="math-container">\[J=\Big(
\begin{matrix}
0 &amp; 1 \\
-1 &amp; 0
\end{matrix}
\Big) 
\mbox{ and } 
e^{-J \Delta t}=\Big(
\begin{matrix}
\cos \Delta t &amp; -\sin\Delta t \\
\sin\Delta t &amp; \cos\Delta t
\end{matrix}
\Big).\]</p><h3 id="Example-2-:-swirling-deformation-flow"><a class="docs-heading-anchor" href="#Example-2-:-swirling-deformation-flow">Example 2 : swirling deformation flow</a><a id="Example-2-:-swirling-deformation-flow-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2-:-swirling-deformation-flow" title="Permalink"></a></h3><p class="math-container">\[\begin{aligned}
\partial_t f + \Big( \sin^2(\pi x) \sin(2\pi y) g(t)\Big) \partial_x f - \Big(\sin^2(\pi y)\sin(2\pi x) g(t)  \Big) \partial_y f = 0, \\
f(t=0, x, y)= f_0(x, y)
\end{aligned}\]</p><p>with <span>$g(t)=\cos(\pi t/T)$</span>. The solution slows down and reverses direction in such a way that the initial condition should be recovered at time <span>$T$</span>: <span>$f(T, x, y)=f_0(x,y)$</span>. This gives a very useful test to validate our methods since we know the exact solution at time <span>$T$</span>. For the initial condition, we consider </p><p class="math-container">\[\begin{equation}
f_0(x, y) = 
\left\{ 
\begin{array}{cc}
1, &amp; \mbox{ if } (x-1)^2+(y-1)^2 &lt;0.8\\
0, &amp; \mbox{ otherwise}.
\end{array}
\right.
\end{equation}\]</p><p>We can choose <span>$T=1.5$</span> and the spatial domain is <span>$[0, 1]^2$</span>. Some results are given in <sup class="footnote-reference"><a id="citeref-leveque" href="#footnote-leveque">[leveque]</a></sup> or <sup class="footnote-reference"><a id="citeref-qiu" href="#footnote-qiu">[qiu]</a></sup>.</p><h3 id="Example-3:-Vlasov-Poisson"><a class="docs-heading-anchor" href="#Example-3:-Vlasov-Poisson">Example 3: Vlasov-Poisson</a><a id="Example-3:-Vlasov-Poisson-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-Vlasov-Poisson" title="Permalink"></a></h3><p class="math-container">\[\partial_t f + y \partial_x f +E \partial_y f = 0, f(t=0, x, y)= f_0(x, y), x\in [0, 4\pi], y\in \mathbb{R},\]</p><p>where the electric field <span>$E$</span> derives from a potential <span>$\phi(t, x)\in\mathbb{R}$</span> which satisfies a Poisson equation</p><p class="math-container">\[\partial_x^2 \phi = \int_{\mathbb{R}} f dy - 1.\]</p><p>The initial condition is</p><p class="math-container">\[f_0(x, y)= \frac{1}{\sqrt{2}\pi}e^{-y^2/2}(1 + 0.001\cos(x/2)).\]</p><p>For this problem, we define the electric energy <span>${\cal E}_e = \int E^2dx$</span> and the kinetic energy <span>${\cal E}_k := \int\!\int y^2 f dx dy$</span> so that the total energy <span>${\cal E}_e+{\cal E}_k$</span> is preserved with time. We can also consider the time evolution of <span>${\cal E}_e$</span> for which we know the behavior.</p><h3 id="Example-4:-guiding-center"><a class="docs-heading-anchor" href="#Example-4:-guiding-center">Example 4: guiding-center</a><a id="Example-4:-guiding-center-1"></a><a class="docs-heading-anchor-permalink" href="#Example-4:-guiding-center" title="Permalink"></a></h3><p class="math-container">\[\partial_t f + E_x \partial_x f +E_y \partial_y f = 0, f(t=0, x, y)= f_0(x, y)\]</p><p>where the electric field <span>$E=(E_x, E_y)(t, x, y)$</span> derives from a potential <span>$\phi(t, x, y)\in\mathbb{R}$</span> which satisfies a Poisson equation </p><p class="math-container">\[\Delta \phi = f.\]</p><p>The spatial domain is <span>$[0, 4\pi]\times [0, 2\pi]$</span> and the initial condition is</p><p class="math-container">\[f_0(x, y)= \sin(y) + 0.015\cos(x/2).\]</p><p>For this problem, the electric energy <span>${\cal E}_e :=\int\!\int (E_x^2+E_y^2)dxdy$</span> and the enstrophy <span>${\cal E}_f:=\int\!\int f^2 dx dy$</span> are preserved with time. Some results are given in <sup class="footnote-reference"><a id="citeref-qiu" href="#footnote-qiu">[qiu]</a></sup> or <sup class="footnote-reference"><a id="citeref-crouseilles" href="#footnote-crouseilles">[crouseilles]</a></sup>.</p><h2 id="Etienne&#39;s-models"><a class="docs-heading-anchor" href="#Etienne&#39;s-models">Etienne&#39;s models</a><a id="Etienne&#39;s-models-1"></a><a class="docs-heading-anchor-permalink" href="#Etienne&#39;s-models" title="Permalink"></a></h2><p>The code for the Etienne&#39;s model is available at <a href="https://github.com/vressegu/sqgmu">https://github.com/vressegu/sqgmu</a> (matlab). If I understood well, the deterministic case is exactly the guiding-center model (with different initial condition but with periodic boundary conditions). Stochastic terms can be added that we perhaps can take into account in our numerical method.</p><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-filbet"><a class="tag is-link" href="#citeref-filbet">filbet</a>F. Filbet, C. Prouveur, <em>High order time discretization for backward semi-Lagrangian methods</em>, Journal of Computational and Applied Mathematics, vol 303, (2016) pp. 171-188.</li><li class="footnote" id="footnote-leveque"><a class="tag is-link" href="#citeref-leveque">leveque</a>R. LeVeque, <em>High-resolution conservative algorithms for advection in incompressible flow</em>, SIAM Journal on Numerical Analysis, (1996), pp.  627-665.  <a href="https://www.jstor.org/stable/2158391?seq=29#metadata_info_tab_contents">https://www.jstor.org/stable/2158391?seq=29#metadata_info_tab_contents</a></li><li class="footnote" id="footnote-qiu"><a class="tag is-link" href="#citeref-qiu">qiu</a>J. Qiu, C.-W. Shu, <em>Conservative high order semi-Lagrangian finite difference WENO methods for advection in incompressible flow</em>, Journal of Computational Physics, Volume 230, Issue 4, 20 (2011), pp. 863-889.</li><li class="footnote" id="footnote-lauritzen"><a class="tag is-link" href="#citeref-lauritzen">lauritzen</a>P. Lauritzen, D. Ramachandran, P. Ullrich, <em>A conservative semi-Lagrangian multi-tracer transport scheme (CSLAM) on the cubed-sphere grid</em>, J. Comput. Phys. 229, (2010), pp. 1401-1424.</li><li class="footnote" id="footnote-crouseilles"><a class="tag is-link" href="#citeref-crouseilles">crouseilles</a>N. Crouseilles, M. Mehrenberger, E. Sonnendrücker <em>Conservative semi-Lagrangian methods for the Vlasov equations</em>, J. Comput. Phys., 229, pp 1927-1953, (2010).</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quickstart/">« Quickstart</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Friday 6 August 2021 16:50">Friday 6 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
