var documenterSearchIndex = {"docs":
[{"location":"rotation/#Rotation","page":"Rotation","title":"Rotation","text":"","category":"section"},{"location":"rotation/","page":"Rotation","title":"Rotation","text":"First simulation using semi-lagrangian method to get a rotation","category":"page"},{"location":"rotation/","page":"Rotation","title":"Rotation","text":"\nimport SemiLagrangian: magicsplit\n\nusing SemiLagrangian\nusing LinearAlgebra\n\nfunction exact!(f, mesh1::UniformMesh{T}, mesh2::UniformMesh{T}, tf::T) where {T}\n    for (i, x) in enumerate(mesh1.points), (j, y) in enumerate(mesh2.points)\n        s, c = sincos(tf)\n        xn, yn = c * x - s * y, s * x + c * y\n        f[i,j] = exp(-13*((xn)^2+(yn+T(6//5))^2))\n    end\nend\n\nfunction run_rotation()\n\n    mesh_sp = UniformMesh( -5.0, 5.0, 256)\n    mesh_v = UniformMesh( -5.0, 5.0, 256)\n    nbdt=50\n    dt = 2pi/nbdt\n    interp_sp = Lagrange(11)\n    interp_v = Lagrange(11)\n    \n    adv = Advection(\n               (mesh_sp, mesh_v),\n               [interp_sp, interp_v],\n               dt,\n               [([1, 2], 1, 1, true), ([2, 1], 1, 2, true)];\n               tab_coef = magicsplit(dt),\n           )\n    \n    sz = sizeall(adv)\n    tabref = zeros(sz)\n    exact!(tabref, mesh_sp, mesh_v, 0.0)\n    \n    pvar = getrotationvar(adv)\n    \n    advdata = AdvectionData(adv, tabref, pvar)\n    \n    diffmax = 0\n    data = getdata(advdata)\n    for ind=1:nbdt\n        while advection!(advdata) end\n        exact!(tabref, mesh_sp, mesh_v, dt*ind)\n        diff = norm(data .- tabref, Inf)\n        diffmax = max(diffmax, diff)\n        println(\"ind=$ind sz=$sz interp=$interp_sp, $interp_v nbdt=$nbdt diff,diffmax=$diff,$diffmax\")\n    end\n\nend\n\nrun_rotation()\n","category":"page"},{"location":"rotation/","page":"Rotation","title":"Rotation","text":"Modules = [SemiLagrangian]\nOrder   = [:type, :function]\nPages   = [\"rotation.jl\"]","category":"page"},{"location":"rotation/#SemiLagrangian.RotationVar","page":"Rotation","title":"SemiLagrangian.RotationVar","text":"mutable struct RotationVar{T, N} <: SemiLagrangian.AbstractExtDataAdv\n\n\n\n\n\n","category":"type"},{"location":"rotation/#SemiLagrangian.getalpha-Tuple{SemiLagrangian.RotationVar, AdvectionData, Any}","page":"Rotation","title":"SemiLagrangian.getalpha","text":"getalpha(pv, self, ind)\n\n\ngetalpha(pv::RotationVar, self::AdvectionData, ind)\n\nImplementation of the interface function that is called before each interpolation in advection\n\n\n\n\n\n","category":"method"},{"location":"rotation/#SemiLagrangian.getrotationvar-Tuple{Advection}","page":"Rotation","title":"SemiLagrangian.getrotationvar","text":"getrotationvar(adv)\n\n\n\n\n\n\n","category":"method"},{"location":"rotation/#SemiLagrangian.initcoef!-Union{Tuple{timeopt}, Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.RotationVar{T, N}, AdvectionData{T, N, timeopt, NoTimeAlg}}} where {T, N, timeopt}","page":"Rotation","title":"SemiLagrangian.initcoef!","text":"initcoef!(pv, self)\n\n\ninitcoef!(pv::RotationVar{T, Nsp, Nv}, self::AdvectionData{T, Nsp, Nv, Nsum})\n\nImplementation of the interface function that is called at the begining of each advection     This is implementation for Vlasov-Poisson equation\n\n\n\n\n\n","category":"method"},{"location":"rotation/#SemiLagrangian.initcoef!-Union{Tuple{timeopt}, Tuple{T}, Tuple{SemiLagrangian.RotationVar{T, 2}, Union{AdvectionData{T, 2, timeopt, ABTimeAlg_ip}, AdvectionData{T, 2, timeopt, ABTimeAlg_new}}}} where {T, timeopt}","page":"Rotation","title":"SemiLagrangian.initcoef!","text":"initcoef!(pv, self)\n\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#Interpolations","page":"Interpolations","title":"Interpolations","text":"","category":"section"},{"location":"interpolations/","page":"Interpolations","title":"Interpolations","text":"Modules = [SemiLagrangian]\nOrder   = [:type, :function]\nPages   = [\"interpolation.jl\"]","category":"page"},{"location":"interpolations/#SemiLagrangian.AbstractInterpolation","page":"Interpolations","title":"SemiLagrangian.AbstractInterpolation","text":"Abstract supertype for all interpolation type\n\nType parameters\n\nT : type of number on witch interpolation works\nedge : type of edge treatment\norder : order of interpolation\n\nImplementation constraint\n\ntabfct::Vector : this attribut must be on the implementation, it is a table of function of size order+1\n\n\n\n\n\n","category":"type"},{"location":"interpolations/#SemiLagrangian.CachePrecal","page":"Interpolations","title":"SemiLagrangian.CachePrecal","text":"mutable struct CachePrecal{T, N, I}\n\n\n\n\n\n","category":"type"},{"location":"interpolations/#SemiLagrangian.ValInv","page":"Interpolations","title":"SemiLagrangian.ValInv","text":"struct ValInv{T}\n\n\n\n\n\n","category":"type"},{"location":"interpolations/#Base.isless-Union{Tuple{T}, Tuple{SemiLagrangian.ValInv{T}, SemiLagrangian.ValInv{T}}} where T","page":"Interpolations","title":"Base.isless","text":"isless(a, b)\n\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SemiLagrangian.autointerp!-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{Array{OpTuple{N, T}, N}, Array{OpTuple{N, T}, N}, Int64, AbstractVector{I}}} where {N, T, I<:AbstractInterpolation}","page":"Interpolations","title":"SemiLagrangian.autointerp!","text":"autointerp!(\n    to,\n    from,\n    nb,\n    interp_t;\n    mpid,\n    t_split,\n    cachethreads\n)\n\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SemiLagrangian.get_allprecal-Union{Tuple{order}, Tuple{T}, Tuple{AbstractInterpolation{T, SemiLagrangian.InsideEdge, order}, Int64, T}} where {T, order}","page":"Interpolations","title":"SemiLagrangian.get_allprecal","text":"get_allprecal(interp, decint, decfloat)\n\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SemiLagrangian.get_order-Union{Tuple{AbstractInterpolation{T, edge, order}}, Tuple{order}, Tuple{edge}, Tuple{T}} where {T, edge, order}","page":"Interpolations","title":"SemiLagrangian.get_order","text":"get_order(_)\n\n\nReturn the order of interpolation implementation       \n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SemiLagrangian.getinverse-Union{Tuple{I}, Tuple{N}, Tuple{T}, Tuple{Tuple{Vararg{Array{T, N}, N}}, Vector{I}}} where {T, N, I<:(AbstractInterpolation{T, SemiLagrangian.CircEdge})}","page":"Interpolations","title":"SemiLagrangian.getinverse","text":"getinverse(dec, interp)\n\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SemiLagrangian.getprecal-Union{Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.CachePrecal{T, N}, Tuple{Vararg{T, N}}}} where {T, N}","page":"Interpolations","title":"SemiLagrangian.getprecal","text":"getprecal(self, alpha)\n\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SemiLagrangian.getprecal-Union{Tuple{T}, Tuple{N}, Tuple{SemiLagrangian.CachePrecal{T, N}, OpTuple{N, T}}} where {N, T<:Real}","page":"Interpolations","title":"SemiLagrangian.getprecal","text":"getprecal(self, alpha)\n\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SemiLagrangian.getprecal-Union{Tuple{T}, Tuple{SemiLagrangian.CachePrecal{T, 1}, Tuple{T}}} where T","page":"Interpolations","title":"SemiLagrangian.getprecal","text":"getprecal(self, alpha)\n\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SemiLagrangian.getprecal-Union{Tuple{T}, Tuple{SemiLagrangian.CachePrecal{T, 1}, T}} where T","page":"Interpolations","title":"SemiLagrangian.getprecal","text":"getprecal(self, alpha)\n\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SemiLagrangian.getprecal-Union{Tuple{T}, Tuple{SemiLagrangian.CachePrecal{T, 2}, Complex{T}}} where T<:Real","page":"Interpolations","title":"SemiLagrangian.getprecal","text":"getprecal(self, alpha)\n\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SemiLagrangian.interpbufc!-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{Array{Array{OpTuple{N, T}, N}, 1}, Array{OpTuple{N, T}, N}, AbstractVector{I}}, Tuple{Array{Array{OpTuple{N, T}, N}, 1}, Array{OpTuple{N, T}, N}, AbstractVector{I}, Int64}} where {N, T, I<:(AbstractInterpolation{T})}","page":"Interpolations","title":"SemiLagrangian.interpbufc!","text":"interpbufc!(t_buf, bufdec, interp_t; ...)\ninterpbufc!(\n    t_buf,\n    bufdec,\n    interp_t,\n    nb;\n    mpid,\n    t_split,\n    cachethreads\n)\n\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SemiLagrangian.interpolate!-Union{Tuple{I}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Tuple{Vararg{Int64, N}}, Array{T, N}, Vector{I}}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Tuple{Vararg{Int64, N}}, Array{T, N}, Vector{I}, Any}} where {T, N, I<:(AbstractInterpolation{T, SemiLagrangian.CircEdge})}","page":"Interpolations","title":"SemiLagrangian.interpolate!","text":"interpolate!(fp, fi, decint, precal, interp)\ninterpolate!(fp, fi, decint, precal, interp, tabmod)\n\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SemiLagrangian.interpolate!-Union{Tuple{I}, Tuple{N}, Tuple{T}, Tuple{Union{AbstractArray{T, N}, AbstractArray{Complex{T}, N}, AbstractArray{OpTuple{N, T}, N}}, Union{AbstractArray{T, N}, AbstractArray{Complex{T}, N}, AbstractArray{OpTuple{N, T}, N}}, Union{AbstractArray{Complex{T}, N}, AbstractArray{OpTuple{N, T}, N}}, AbstractVector{I}}} where {T, N, I<:(AbstractInterpolation{T})}","page":"Interpolations","title":"SemiLagrangian.interpolate!","text":"interpolate!(\n    fp,\n    fi,\n    bufdec,\n    interp_t;\n    tabmod,\n    mpid,\n    t_split,\n    cachethreads\n)\n\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SemiLagrangian.interpolate!-Union{Tuple{I}, Tuple{N}, Tuple{T}, Tuple{Union{AbstractArray{T, N}, AbstractArray{Complex{T}, N}}, Union{AbstractArray{T, N}, AbstractArray{Complex{T}, N}}, Function, AbstractVector{I}}} where {T, N, I<:(AbstractInterpolation{T})}","page":"Interpolations","title":"SemiLagrangian.interpolate!","text":"interpolate!(fp, fi, dec, interp_t; tabmod, cache)\n\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SemiLagrangian.interpolate!-Union{Tuple{I}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64, Vector{T}, Vector{I}}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64, Vector{T}, Vector{I}, Any}} where {T, I<:(AbstractInterpolation{T, SemiLagrangian.CircEdge})}","page":"Interpolations","title":"SemiLagrangian.interpolate!","text":"interpolate!(fp, fi, decint, precal, tinterp)\ninterpolate!(fp, fi, decint, precal, tinterp, tabmod)\n\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SemiLagrangian.interpolate!-Union{Tuple{order}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64, Array{Vector{T}, 1}, AbstractInterpolation{T, SemiLagrangian.InsideEdge, order}}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64, Array{Vector{T}, 1}, AbstractInterpolation{T, SemiLagrangian.InsideEdge, order}, Any}} where {T, order}","page":"Interpolations","title":"SemiLagrangian.interpolate!","text":"interpolate!(fp, fi, decint, allprecal, interp)\ninterpolate!(fp, fi, decint, allprecal, interp, tabmod)\n\n\napply an offset to the function fi interpolate by interp struct, the result is in fp vector, decint and precal are precompute with getprecal method, the TypeEdge is InsideEdge, it is a marginal case\n\nArguments\n\nfp::AbstractVector : output vector\nfi::AbstractVector : input vector\ndecint : offset in units of dx\nallprecal::Vector{Vector{T}} : vector of vector of length order+1 precompute with getprecal(interp, dec) (dec is the offset)\ninterp::AbstractInterpolation{T, InsideEdge, order} : interpolation implementation, note that TypeEdge is CircEdge\ntabmod=gettabmod(length(fi)) : precompute for \"begin at one\" modulo\n\nReturns :\n\nNo return\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SemiLagrangian.interpolate!-Union{Tuple{order}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64, Vector{T}, AbstractInterpolation{T, SemiLagrangian.CircEdge, order}}, Tuple{AbstractVector{T}, AbstractVector{T}, Int64, Vector{T}, AbstractInterpolation{T, SemiLagrangian.CircEdge, order}, Any}} where {T, order}","page":"Interpolations","title":"SemiLagrangian.interpolate!","text":"interpolate!(fp, fi, decint, precal, interp)\ninterpolate!(fp, fi, decint, precal, interp, tabmod)\n\n\napply an offset to the function fi interpolate by interp struct, the result is in fp vector, decint and precal are precompute with getprecal method, the TypeEdge is CircEdge\n\nArguments\n\nfp::AbstractVector : output vector\nfi::AbstractVector : input vector\ndecint : offset in units of dx\nprecal::Vector : vector of length order+1 precompute with getprecal(interp, dec) (dec is the offset)\ninterp::AbstractInterpolation{T, CircEdge, order} : interpolation implementation, note that TypeEdge is CircEdge\ntabmod=gettabmod(length(fi)) : precompute for \"begin at one\" modulo\n\nReturns :\n\nNo return\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SemiLagrangian.interpolate!-Union{Tuple{order}, Tuple{edge}, Tuple{T}, Tuple{Any, Any, Any, AbstractInterpolation{T, edge, order}}} where {T, edge, order}","page":"Interpolations","title":"SemiLagrangian.interpolate!","text":"interpolate!(fp, fi, dec, interp)\n\n\napply the offset dec to the function fi interpolate by interp struct, the result is in fp Vector\n\nArguments\n\nfp : output vector of length n\nfi : input vector of length n\ndec : offset in units of dx\ninterp::AbstractInterpolation : interpolation implementation\n\nReturns :\n\nNo return\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SemiLagrangian.interpolatemod!-Union{Tuple{I}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Tuple{Array{T, N}, Array{T, N}}, AbstractVector{I}, Union{UniformMesh{T}, T}}} where {T, N, I<:(AbstractInterpolation{T, SemiLagrangian.CircEdge})}","page":"Interpolations","title":"SemiLagrangian.interpolatemod!","text":"interpolatemod!(fp, fi, bufc, interp_t, lgmesh)\n\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SemiLagrangian.sol-Tuple{AbstractInterpolation, AbstractArray}","page":"Interpolations","title":"SemiLagrangian.sol","text":"sol(_, b)\n\n\nInterface method to transform the treated line, by default this method does nothing\n\nArguments :\n\n_::AbstractInterpolation : interpolation implementation\nline::AbstractVector : line to transform\n\nReturn :\n\nThe transformed line\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SemiLagrangian.sol-Union{Tuple{I}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{I}, Union{AbstractArray{T, N}, AbstractArray{Complex{T}, N}, AbstractArray{OpTuple{N, T}, N}}}} where {T<:Real, N, I<:(AbstractInterpolation{T})}","page":"Interpolations","title":"SemiLagrangian.sol","text":"sol(interp_t, b)\n\n\n\n\n\n\n","category":"method"},{"location":"contents/#Index","page":"Contents","title":"Index","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"","category":"page"},{"location":"vlasov-poisson/#Vlasov-Poisson","page":"Vlasov-Poisson","title":"Vlasov-Poisson","text":"","category":"section"},{"location":"vlasov-poisson/","page":"Vlasov-Poisson","title":"Vlasov-Poisson","text":"\nusing SemiLagrangian\nusing Plots\n\nfunction run_simulation(nbdt, sz, dt, interp, tab_coef)\n    \n    epsilon = 0.001\n\n    xmin, xmax, nx = 0., 4π, sz[1]\n    vmin, vmax, nv = -6., 6., sz[2]\n\n    mesh_x = UniformMesh(xmin, xmax, nx)\n    mesh_v = UniformMesh(vmin, vmax, nv)\n\n    states = [([1, 2], 1, 1, true), ([2, 1], 1, 2, true)]\n\n    adv = Advection((mesh_x, mesh_v), [interp, interp], dt, states; \n        tab_coef, timeopt = NoTimeOpt)\n    \n    kx = 0.5 \n    fct_x(x) = epsilon * cos(kx * x) + 1\n    fct_v(v) = exp(-v^2 / 2) / sqrt(2π)\n\n    lgn_x = fct_x.(mesh_x.points)\n    lgn_v = fct_v.(mesh_v.points)\n\n    data = dotprod((lgn_x, lgn_v))\n\n    pvar = getpoissonvar(adv)\n\n    advd = AdvectionData(adv, data, pvar)\n\n    time = Float64[]\n    el = Float64[]\n    for i = 1:nbdt\n        while advection!(advd) end\n        push!(time, advd.time_cur)\n        push!(el, compute_ee(advd))\n    end\n    return time, el\nend\n\nnbdt = 1000\nsz = (64, 64)\ndt = 0.1\ninterp = Lagrange(9, Float64)\ntab_coef = strangsplit(dt)\ntime, el = run_simulation( nbdt, sz, dt, interp, tab_coef)\nplot(time, 0.5 .* log.(el.^2))\n","category":"page"},{"location":"advection/#Advection","page":"Advection","title":"Advection","text":"","category":"section"},{"location":"advection/","page":"Advection","title":"Advection","text":"Modules = [SemiLagrangian]\nOrder   = [:type, :function]\nPages   = [\"splitting.jl\", \"advection.jl\"]","category":"page"},{"location":"advection/#SemiLagrangian.hamsplit_3_11-Union{Tuple{T}, Tuple{T, Any}} where T<:Number","page":"Advection","title":"SemiLagrangian.hamsplit_3_11","text":"hamsplit_3_11(dt)\nhamsplit_3_11(dt, fltrace)\n\n\n\n\n\n\n","category":"method"},{"location":"advection/#SemiLagrangian.magicsplit-Tuple{T} where T","page":"Advection","title":"SemiLagrangian.magicsplit","text":"magicsplit(dt)\n\n\n\n\n\n\n","category":"method"},{"location":"advection/#SemiLagrangian.nosplit-Tuple{T} where T","page":"Advection","title":"SemiLagrangian.nosplit","text":"nosplit(dt)\n\n\n\n\n\n\n","category":"method"},{"location":"advection/#SemiLagrangian.order6split-Tuple{T} where T","page":"Advection","title":"SemiLagrangian.order6split","text":"order6split(dt)\n\n\n\n\n\n\n","category":"method"},{"location":"advection/#SemiLagrangian.standardsplit-Tuple{T} where T","page":"Advection","title":"SemiLagrangian.standardsplit","text":"standardsplit(dt)\n\n\n\n\n\n\n","category":"method"},{"location":"advection/#SemiLagrangian.strangsplit-Tuple{T} where T","page":"Advection","title":"SemiLagrangian.strangsplit","text":"strangsplit(dt)\n\n\n\n\n\n\n","category":"method"},{"location":"advection/#SemiLagrangian.table2split-Tuple{T} where T","page":"Advection","title":"SemiLagrangian.table2split","text":"table2split(dt)\n\n\n\n\n\n\n","category":"method"},{"location":"advection/#SemiLagrangian.triplejumpsplit-Tuple{T} where T","page":"Advection","title":"SemiLagrangian.triplejumpsplit","text":"triplejumpsplit(dt)\n\n\n\n\n\n\n","category":"method"},{"location":"advection/#SemiLagrangian.Advection","page":"Advection","title":"SemiLagrangian.Advection","text":"struct Advection{T, N, I, timeopt, timealg, ordalg}\n\nAdvection{T}\nAdvection(\n    t_mesh::NTuple{N,UniformMesh{T}},\n    t_interp::Vector{I}\n    dt_base::T;\n    tab_coef = [1 // 1],\n    tab_fct = missing,\n    timeopt::TimeOptimization = NoTimeOpt,\n) where {T, N, I <: AbstractInterpolation{T}}\n\nImmutable structure that contains constant parameters for multidimensional advection\n\nType parameters\n\nT::DataType : type of data\nN : number of dimensions\nI : commun type of interpolation\ntimeopt::TimeOptimization : time optimization\n\nArguments\n\nt_mesh::NTuple{N, UniformMesh{T}} : tuple of meshes (one for each dimension)\nt_interp::Vector{I} : tuple of interpolations (one for each dimension)\ndt_base::T : time delta for one advection series\n\nKeywords\n\ntab_coef=[1//2, 1//1, 1//2] : coefficient table for one advection series, the   coefficients at odd indexes is for space advection series, the coefficients at even indexes is for velocity advection series\ntab_fct=[identity, identity, identity] : function table for one advection series, with the same indexes than tab_coef\n\nImplementation\n\nsizeall : tuple of the sizes of all dimensions (space before velocity)\nt_mesh_sp : tuple of space meshes\nt_mesh_v : tuple of velocity meshes\nt_interp_sp : tuple of space interpolation types\nt_interp_v : tuple of velocity interpolation types\ndt_base::T : time unit of an advection series\ntab_coef : coefficient table\nv_square : precompute for ke\nnbsplit : number of slices for split\nmpiid : MPI id\n\nThrows\n\nArgumentError : Nsp must be less or equal to Nv.\n\n\n\n\n\n","category":"type"},{"location":"advection/#SemiLagrangian.AdvectionData","page":"Advection","title":"SemiLagrangian.AdvectionData","text":"mutable struct AdvectionData{T, N, timeopt, timealg}\n\nAdvectionData{T,N,timeopt}\nAdvectionData(\nadv::Advection{T,N,timeopt},\ndata::Array{T,N},\nparext)\n\nMutable structure that contains variable parameters of advection series\n\nType parameters\n\nT::DataType : type of data\nN : number of dimensions\ntimeopt::TimeOptimization : time optimization\n\nArguments\n\nadv::Advection{T,N} : link to the constant data of this advection\ndata::Array{T,Nsum} : Initial data of this advection\nparext : external data of this advection to compute alpha of each interpolations\n\nImplementation\n\nadv::Advection{T,N,timeopt} : link to the constant data of this advection\nstate_coef::Int : state that is the index of tab_coef, it is from one to lenth(tab_coef)\nstate_dim::Int : the dimension index, from 1 to Nsp in space states, from one to Nv in velocity state\ndata::Array{T,Nsum} : it is the working buffer\nbufdata::Vector{T} : vector of the same size of the working buffer\nfmrtabdata::NTuple{Nsum,Array{T,Nsum}} : tuple of array with the same size than data but with permutated dimensions\nt_buf::NTuple{Nsum, Array{T,2}} : tuple of buffer that is used to get the linear data for interpolation, one buffer per thread\ncache_alpha::Union{T,Nothing} : cache for precal, the precal is compute only when the alpha or decint values change\ncache_decint::Int64 : for precal cache\ncache_precal::Vector{T} : for precal cache\nparext::ExtDataAdv : external data of this advection to compute alpha of each interpolations\n\nMethods to define\n\ninitcoef!(parext::AbstractExtDataAdv, self::Advection1dData) : this method called at the beginning of each advection to initialize parext data. The self.parext mutable structure is the only data that initcoef! can modify otherwise it leads to unpredictable behaviour.\ngetalpha(parext::AbstractExtDataAdv, self::Advection1dData, ind) : return the alpha number that is used for interpolation.\ngetperm(parext::AbstractExtDataAdv, advd::Advection1dData) : get the permutation of the dimension as a function of the current state, the dimension where advection occurs must be first, the dimensions used to compute alpha must be at the end.\n\nadv::Advection\nstate_gen::Int64\ntime_cur::Any\ndata::Array\nbufdata::Array\nfmrtabdata::Array{Array{T, N}, 1} where {T, N}\nt_buf::Array{Array{T}, 1} where T\nt_itr::Any\ntt_split::Any\nt_cache::Array{Array{SemiLagrangian.CachePrecal{T}, 1}, 1} where T\nparext::SemiLagrangian.AbstractExtDataAdv\nbufcur::Union{Missing, Array{OpTuple{N, T}, N}} where {T, N}\nt_bufc::Array{Array{OpTuple{N, T}, N}, 1} where {T, N}\ninitdatas::Union{Missing, Array{Array{T, N}, 1}} where {T, N}\n\n\n\n\n\n","category":"type"},{"location":"advection/#SemiLagrangian.StateAdv","page":"Advection","title":"SemiLagrangian.StateAdv","text":"struct StateAdv{N}\n\nind::Int64\nperm::Vector{Int64}\ninvp::Vector{Int64}\nndims::Int64\nstcoef::Int64\nisconstdec::Bool\n\n\n\n\n\n","category":"type"},{"location":"advection/#SemiLagrangian.advection!-Union{Tuple{AdvectionData{T, N, timeopt, timealg}}, Tuple{timealg}, Tuple{timeopt}, Tuple{N}, Tuple{T}} where {T, N, timeopt, timealg}","page":"Advection","title":"SemiLagrangian.advection!","text":"advection!(self)\n\n\nAdvection function of a multidimensional function f discretized on mesh\n\nArgument\n\nself::AdvectionData : mutable structure of variables data\n\nReturn value\n\ntrue : means that the advection series must continue\nfalse : means that the advection series is ended.\n\n\n\n\n\n","category":"method"},{"location":"advection/#SemiLagrangian.copydata!-Union{Tuple{timealg}, Tuple{timeopt}, Tuple{N}, Tuple{T}, Tuple{AdvectionData{T, N, timeopt, timealg}, Any}} where {T, N, timeopt, timealg}","page":"Advection","title":"SemiLagrangian.copydata!","text":"copydata!(advd, f)\n\n\n\n\n\n\n","category":"method"},{"location":"advection/#SemiLagrangian.decbegin!-Union{Tuple{I}, Tuple{Any, Any, Vector{I}}} where I<:AbstractInterpolation","page":"Advection","title":"SemiLagrangian.decbegin!","text":"decbegin!(t_trv, t_cal, t_interp)\n\n\n\n\n\n\n","category":"method"},{"location":"advection/#SemiLagrangian.getformdata-Tuple{AdvectionData}","page":"Advection","title":"SemiLagrangian.getformdata","text":"getformdata(advd)\n\n\n\n\n\n\n","category":"method"},{"location":"advection/#SemiLagrangian.initcoef!-Union{Tuple{AdvectionData{T, N, timeopt, timealg}}, Tuple{timealg}, Tuple{timeopt}, Tuple{N}, Tuple{T}} where {T, N, timeopt, timealg}","page":"Advection","title":"SemiLagrangian.initcoef!","text":"initcoef!(self)\n\n\n\n\n\n\n","category":"method"},{"location":"advection/#SemiLagrangian.nextstate!-Tuple{AdvectionData}","page":"Advection","title":"SemiLagrangian.nextstate!","text":"nextstate!(self)\n\n\n\n\n\n\n","category":"method"},{"location":"advection/#SemiLagrangian.retns-Tuple{AdvectionData, SemiLagrangian.AbstractExtDataAdv}","page":"Advection","title":"SemiLagrangian.retns","text":"retns(self, extdata)\n\n\nFunction called at the end of advection function to update internal state of AdvectionData structure\n\nArgument\n\nself::AdvectionData{T, N} : object to update\n\nreturn value\n\nret::Bool : true if the series must continue               false at the end of the series.\n\n\n\n\n\n","category":"method"},{"location":"advection/#SemiLagrangian.sizeall-Tuple{Advection}","page":"Advection","title":"SemiLagrangian.sizeall","text":"sizeall(adv)\n\n\nReturn a tuple of the sizes of each dimensions\n\nArgument\n\nadv::Advection : Advection structure.\n\n\n\n\n\n","category":"method"},{"location":"surfacequasigeostrophic/#Surface-Quasi-Geostrosphic","page":"Surface Quasi-Geostrosphic","title":"Surface Quasi-Geostrosphic","text":"","category":"section"},{"location":"surfacequasigeostrophic/","page":"Surface Quasi-Geostrosphic","title":"Surface Quasi-Geostrosphic","text":"Modules = [SemiLagrangian]\nOrder   = [:type, :function]\nPages   = [\"quasigeostrophic.jl\"]","category":"page"},{"location":"surfacequasigeostrophic/#SemiLagrangian.GeoConst","page":"Surface Quasi-Geostrosphic","title":"SemiLagrangian.GeoConst","text":"struct GeoConst{T, N}\n\nadv::Advection\nodg_b::Any\ncoefrsqk::Tuple{Vararg{Array{Complex{T}, N}, N}} where {T, N}\npfftbig::Union{Missing, SemiLagrangian.PrepareFftBig{T}} where T\n\n\n\n\n\n","category":"type"},{"location":"surfacequasigeostrophic/#SemiLagrangian.GeoVar","page":"Surface Quasi-Geostrosphic","title":"SemiLagrangian.GeoVar","text":"struct GeoVar{T, N} <: SemiLagrangian.AbstractExtDataAdv\n\ngc::SemiLagrangian.GeoConst\n\n\n\n\n\n","category":"type"},{"location":"surfacequasigeostrophic/#SemiLagrangian.getalpha-Union{Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.GeoVar{T, N}, AdvectionData{T}, CartesianIndex, CartesianIndex}} where {T, N}","page":"Surface Quasi-Geostrosphic","title":"SemiLagrangian.getalpha","text":"getalpha(_, self, indext, indbuf)\n\n\n\n\n\n\n","category":"method"},{"location":"surfacequasigeostrophic/#SemiLagrangian.getgeovar-Union{Tuple{Advection{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Surface Quasi-Geostrosphic","title":"SemiLagrangian.getgeovar","text":"getgeovar(adv; kwargs...)\n\n\n\n\n\n\n","category":"method"},{"location":"surfacequasigeostrophic/#SemiLagrangian.initcoef!-Union{Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.GeoVar{T, N}, AdvectionData{T, N}}} where {T, N}","page":"Surface Quasi-Geostrosphic","title":"SemiLagrangian.initcoef!","text":"initcoef!(geoc, advd)\n\n\n\n\n\n\n","category":"method"},{"location":"surfacequasigeostrophic/#SemiLagrangian.initdata!-Union{Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.GeoVar{T, N}, AdvectionData{T, N}}} where {T, N}","page":"Surface Quasi-Geostrosphic","title":"SemiLagrangian.initdata!","text":"initdata!(geoc, advd)\n\n\n\n\n\n\n","category":"method"},{"location":"modele_2d/#Two-dimensional-problems","page":"Two dimensions","title":"Two-dimensional problems","text":"","category":"section"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"In this document, we detail some aspects of the 2-dimensional semi-Lagrangian method and give some examples to validate the implementation.","category":"page"},{"location":"modele_2d/#General-context","page":"Two dimensions","title":"General context","text":"","category":"section"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"We consider 2D transport equation of the form ","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"tag1\npartial_t f + u_x partial_x f + u_y partial_y f = 0 f(t=0 x y)= f_0(x y) x yin Omegasubset mathbbR^2","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"where the advection field (u_x u_y)(t x y) satisfies the incompressibility condition partial_x u_x + partial_y u_y=0 which implies (1) can be reformulated as","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"partial_t f + partial_x( u_x  f )+ partial_y(u_y  f) = 0 f(t=0 x y)= f_0(x y)","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"from which we deduce the mass conservation intint f(t x y) dxdy = intint f_0(x y) dxdy. To solve numerically (1), we will use a 2D semi-Lagrangian method which is based on the fact that the solution f is constant along the characteristics X(t)=(x(t) y(t)) defined by","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"dotX(t) = U(t X(t))  X(s) = X_g","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"with U(t X)=U(t x y)=(u_x(t x y) u_y(t x y)), s is a time and X_g is a prescribed condition (which will be a grid point). Hence, we can write f(s X(s))=f(t X(t)) for all t s. Considering a discretization of the time t^n=nDelta t with nin mathbbN and Delta t0 the time step, we rewrite the latter equality with s=t^n+1 and t=t^n to get ","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"f(t^n+1 X_g) = f(t^n X(t^n))","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"We want to compute the left hand side which corresponds to the numerical solution at time t^n+1 and at the grid point X_g. To do so, we assume (by induction) that the solution is known at time t^n and at the grid points X_g, thus, we have to interpolate (in 2D) to compute f(t^n X(t^n)). The semi-Lagrangian methods can be split into two steps","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"compute X(t^n)\ncompute f(t^n X(t^n)): from the known values f(t^n X_g), interpolate at X(t^n).","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"These two steps are details in the next section.","category":"page"},{"location":"modele_2d/#Details-on-the-2D-semi-Lagrangian-method","page":"Two dimensions","title":"Details on the 2D semi-Lagrangian method","text":"","category":"section"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"The two steps of the semi-Lagrangian are detailed and some examples are given.","category":"page"},{"location":"modele_2d/#ODE-solver","page":"Two dimensions","title":"ODE solver","text":"","category":"section"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"First, we need to compute X(t^n) which the solution at time t^n of","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"tag2\ndotX(t) = U(t X(t))  X(t^n+1) = X_g","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"When U is simple enough, X(t^n) can be computed analytically but in general, we need a solver of this differential equation. The main difficulty comes from the fact that (2) has to be solved backward in time and when the time dependency of U is nonlinearly coupled to the solution f itself (see Examples 3 and 4 below), we do not know U(t dot) for tt^n (and time extrapolation has to be used [filbet]).","category":"page"},{"location":"modele_2d/#First-order","page":"Two dimensions","title":"First order","text":"","category":"section"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"A simple scheme to compute X(t^n) is the Euler scheme applied to (2)","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"fracX(t^n+1) - X(t^n)Delta t = U(t^n X(t^n+1))","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"and using the condition X(t^n+1) = X_g, we get the following first order approximation for X(t^n) ","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"X(t^n) = X_g - Delta t U(t^n X_g)","category":"page"},{"location":"modele_2d/#Second-order","page":"Two dimensions","title":"Second order","text":"","category":"section"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"A mid-point scheme (which is second order accurate) can be used to solve (2):","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"fracX(t^n+1) - X(t^n)Delta t = UBig(t^n+12 fracX(t^n+1) + X(t^n)2Big)","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"which gives an implicit expression for X(t^n) ","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"beginequation\nlabelode_2nd_imp\nX(t^n) = X(t^n+1) -Delta t  UBig(t^n+12 fracX(t^n+1) + X(t^n)2Big)\nendequation","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"As mentioned above, we first need to extrapolate U(t^n+12 cdot). To do so, we use U(t^n-1 cdot) and U(t^n cdot) and we construct a first order Lagrange polynomial cal L(t) tint^n-1 t^n","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"cal L(t) = U(t^n cdot) fract^n-1-tDelta t + U(t^n-1 cdot) fract - t^nDelta t","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"We then approximate U(t^n+12 cdot) by cal L(t^n+12). We then have to solve \\eqref{ode2ndimp} using a fixed point","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"X^n k+1 = X_g -Delta t  cal LBig(t^n+12 fracX_g + X^nk2Big)  mbox for  kgeq 0 X^n 0=X_g","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"up to convergence.","category":"page"},{"location":"modele_2d/#Extension-to-higher-order","page":"Two dimensions","title":"Extension to higher order","text":"","category":"section"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"We can look at the schemes proposed in [filbet] but we can also use the package DifferentialEquations.jl","category":"page"},{"location":"modele_2d/#2D-Interpolation","page":"Two dimensions","title":"2D Interpolation","text":"","category":"section"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"Once X(t^n) has been computed using the techniques detailed before, one has to compute f(t^n X(t^n)). Since the grid values f(t^n X_g) are known, we can reconstruct a piecewise 2D polynomial function cal P(x y) x yin Omega using Lagrange or splines such that f(t^n X_g) = cal P(X_g), and then we approximate f(t^n X(t^n)) approx cal P(X(t^n)) We consider a cartesian grid of N_xtimes N_y points x_i = (i-1)Delta x and y_j =(j-1)Delta y for i=1 dots N_x and j=1 dots N_y. We assume periodicity in x and y which means f(x_N_x+1 y) = f(x_1 y) and f(x y_N_y+1) = f(x y_1).","category":"page"},{"location":"modele_2d/#Lagrange-interpolation","page":"Two dimensions","title":"Lagrange interpolation","text":"","category":"section"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"A tensor product can be done. If we denote L_xi and L_yj the Lagrange polynomial of degree 2d+1 in the x and y direction L_xi(x) = Pi_k=i-d kneq i^i+d frac(x-x_k)(x_i-x_k) and L_yj(x) = Pi_k=j-d kneq j^j+d frac(y-y_k)(y_j-y_k). Then, we have","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"f(xy) approx cal P(xy) =sum_i=1^N_x sum_j=1^N_y f(x_iy_j) L_xi(x)L_yj(y)","category":"page"},{"location":"modele_2d/#Splines-interpolation","page":"Two dimensions","title":"Splines interpolation","text":"","category":"section"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"For cubic splines, one can use","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"splinePP ","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"which I try to explain below.","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"We introduce the tridiagonal matrix Ain cal M_Nx+1 N_x+1 with 4 on the diagonal and 1 on the two extradiagonals. We consider f(x_i y_j) for i=1 dots N_x and j=1 dots N_y and we denote Fin cal M_N_x+1 N_y the matrix such that F_ij = f(x_iy_j) for i=1 dots N_x and j=1 dots N_y and F_N_x+1 j= f(x_1 y_j) for periodicity. We compute the splines coefficients as","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"solve A eta_j = 6 f(y_j)  forall j=1 dots N_y with eta_jin mathbbR^N_x+1\ngestion du bord (Pierre ?) pour obtenir eta(1Nx+3 1N_y+1)\nsolve A tt coef_i  = 6 eta(i)  forall i=1 cdots N_x+3  with tt coef_iin mathbbR^N_y+1\ngestion du bord (Pierre ?) pour obtenir coef(1Nx+3 1N_y+3)","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"f(xy) approx cal S(xy) = sum_isum_j tt coef_ij B_i(x) B_j(y)","category":"page"},{"location":"modele_2d/#Some-examples","page":"Two dimensions","title":"Some examples","text":"","category":"section"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"In this part, some examples of increasing difficulty are proposed to validate our algorithms.","category":"page"},{"location":"modele_2d/#Example-1-:-rotation","page":"Two dimensions","title":"Example 1 : rotation","text":"","category":"section"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"partial_t f + y partial_x f - x partial_y f = 0 f(t=0 x y)= f_0(x y)","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"We already discussed this test and we have to check it again. In this case, the characteristics can be solved exactly in time since X(t^n) = e^-J Delta tX_g with J the symplectic matrix. This test will enable us to validate the 2D interpolation step. Here","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"J=Big(\nbeginmatrix\n0  1 \n-1  0\nendmatrix\nBig) \nmbox and  \ne^-J Delta t=Big(\nbeginmatrix\ncos Delta t  -sinDelta t \nsinDelta t  cosDelta t\nendmatrix\nBig)","category":"page"},{"location":"modele_2d/#Example-2-:-swirling-deformation-flow","page":"Two dimensions","title":"Example 2 : swirling deformation flow","text":"","category":"section"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"beginaligned\npartial_t f + Big( sin^2(pi x) sin(2pi y) g(t)Big) partial_x f - Big(sin^2(pi y)sin(2pi x) g(t)  Big) partial_y f = 0 \nf(t=0 x y)= f_0(x y)\nendaligned","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"with g(t)=cos(pi tT). The solution slows down and reverses direction in such a way that the initial condition should be recovered at time T: f(T x y)=f_0(xy). This gives a very useful test to validate our methods since we know the exact solution at time T. For the initial condition, we consider ","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"beginequation\nf_0(x y) = \nleft \nbeginarraycc\n1  mbox if  (x-1)^2+(y-1)^2 08\n0  mbox otherwise\nendarray\nright\nendequation","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"We can choose T=15 and the spatial domain is 0 1^2. Some results are given in [leveque] or [qiu].","category":"page"},{"location":"modele_2d/#Example-3:-Vlasov-Poisson","page":"Two dimensions","title":"Example 3: Vlasov-Poisson","text":"","category":"section"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"partial_t f + y partial_x f +E partial_y f = 0 f(t=0 x y)= f_0(x y) xin 0 4pi yin mathbbR","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"where the electric field E derives from a potential phi(t x)inmathbbR which satisfies a Poisson equation","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"partial_x^2 phi = int_mathbbR f dy - 1","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"The initial condition is","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"f_0(x y)= frac1sqrt2pie^-y^22(1 + 0001cos(x2))","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"For this problem, we define the electric energy cal E_e = int E^2dx and the kinetic energy cal E_k = intint y^2 f dx dy so that the total energy cal E_e+cal E_k is preserved with time. We can also consider the time evolution of cal E_e for which we know the behavior.","category":"page"},{"location":"modele_2d/#Example-4:-Guiding-center","page":"Two dimensions","title":"Example 4: Guiding-center","text":"","category":"section"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"partial_t f + E_x partial_x f +E_y partial_y f = 0 f(t=0 x y)= f_0(x y)","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"where the electric field E=(E_x E_y)(t x y) derives from a potential phi(t x y)inmathbbR which satisfies a Poisson equation ","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"Delta phi = f","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"The spatial domain is 0 4pitimes 0 2pi and the initial condition is","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"f_0(x y)= sin(y) + 0015cos(x2)","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"For this problem, the electric energy cal E_e =intint (E_x^2+E_y^2)dxdy and the enstrophy cal E_f=intint f^2 dx dy are preserved with time. Some results are given in [qiu] or [crouseilles].","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"","category":"page"},{"location":"modele_2d/#References","page":"Two dimensions","title":"References","text":"","category":"section"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"[filbet]: F. Filbet, C. Prouveur, High order time discretization for backward semi-Lagrangian methods, Journal of Computational and Applied Mathematics, vol 303, (2016) pp. 171-188.","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"[leveque]: R. LeVeque, High-resolution conservative algorithms for advection in incompressible flow, SIAM Journal on Numerical Analysis, (1996), pp.  627-665.  https://www.jstor.org/stable/2158391?seq=29#metadata_info_tab_contents","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"[qiu]: J. Qiu, C.-W. Shu, Conservative high order semi-Lagrangian finite difference WENO methods for advection in incompressible flow, Journal of Computational Physics, Volume 230, Issue 4, 20 (2011), pp. 863-889.","category":"page"},{"location":"modele_2d/","page":"Two dimensions","title":"Two dimensions","text":"[crouseilles]: N. Crouseilles, M. Mehrenberger, E. Sonnendrücker Conservative semi-Lagrangian methods for the Vlasov equations, J. Comput. Phys., 229, pp 1927-1953, (2010).","category":"page"},{"location":"bspline/#B-spline","page":"B-spline","title":"B-spline","text":"","category":"section"},{"location":"bspline/","page":"B-spline","title":"B-spline","text":"Modules = [SemiLagrangian]\nOrder   = [:type, :function]\nPages   = [\"spline.jl\", \"bspline.jl\", \"bsplinelu.jl\", \"bsplinefft.jl\"]","category":"page"},{"location":"bspline/#SemiLagrangian.BSpline","page":"B-spline","title":"SemiLagrangian.BSpline","text":"abstract type BSpline{T, edge, order} <: AbstractInterpolation{T, edge, order}\n\nBSpline{T, edge, order} <: AbstractInterpolation{T, edge, order}\n\nAbstract supertype for all bspline interpolation type\n\n\n\n\n\n","category":"type"},{"location":"bspline/#SemiLagrangian.BSplineLU","page":"B-spline","title":"SemiLagrangian.BSplineLU","text":"struct BSplineLU{T, edge, order} <: SemiLagrangian.BSpline{T, edge, order}\n\nBSplineLU{T, edge, order} <: AbstractInterpolation{T, edge, order}\n\nType containing spline coefficients for b-spline interpolation\n\nType parameters\n\nT : the type of data that is interpolate\nedge::TypeEdge=CircEdge : true if function is circular\norder::Int : order of lagrange interpolation\n\nImplementation :\n\nls::LuSpline{T} : the LU matrix\ntabfct::Vector{Polynomial{T}} : function table for interpolation\n\nArguments :\n\nn : size of the matrix\norder : the order of interpolation\n[T::DataType=Float64] : The type values to interpolate \n\n\n\n\n\n","category":"type"},{"location":"bspline/#SemiLagrangian.LuSpline","page":"B-spline","title":"SemiLagrangian.LuSpline","text":"struct LuSpline{T}\n\nstruct LuSpline{T}\nLuSpline(n, t::Vector{T}; iscirc=true, isLU=true) where{T}\n\nStructure of a LU decomposition of circular banded matrix, a LU decomposition can be stored in a Matrix which is equal to L + U - I. For a circular Banded matrix all non zero coefficients are in the band and in the last columns and lines\n\nImplementation\n\nband::Matrix{T} : matrix of size (kl+ku+1, n-kl)\nku : size of the band upper the diagonal\nkl : size of the band lower the diagonal\niscirc : true if and only if original matrix is circular\nisLU : true if LU decomposition has been perform\nlastcols : only in circular case, Matrix of size (n-ku, kl) that represents teh last columns of matrix\nlastrows : only in circular case, Matrix of size (n, ku) that represents the last rows of matrix\n\nArguments\n\n'n' : size of the matrix\n't::Vector{T}` : vector of all values, the size is order+1, where order is the order of the spline.\n\n\n\n\n\n","category":"type"},{"location":"bspline/#SemiLagrangian.decLULu-NTuple{4, Any}","page":"B-spline","title":"SemiLagrangian.decLULu","text":"decLULu(iscirc, band, lastcols, lastrows)\n\n\n\n\n\n\n","category":"method"},{"location":"bspline/#SemiLagrangian.sol!-Union{Tuple{I}, Tuple{T}, Tuple{AbstractVector{I}, BSplineLU{T}, AbstractVector{I}}} where {T, I}","page":"B-spline","title":"SemiLagrangian.sol!","text":"sol!(X, bsp, Y)\n\n\n\n\n\n\n","category":"method"},{"location":"bspline/#SemiLagrangian.sol!-Union{Tuple{I}, Tuple{T}, Tuple{AbstractVector{I}, SemiLagrangian.LuSpline{T}, AbstractVector{I}}} where {T, I}","page":"B-spline","title":"SemiLagrangian.sol!","text":"sol!(X, spA, Y)\n\n\n\n\n\n\n","category":"method"},{"location":"bspline/#SemiLagrangian.sol-Union{Tuple{I}, Tuple{T}, Tuple{BSplineLU{T}, AbstractVector{I}}} where {T<:Number, I}","page":"B-spline","title":"SemiLagrangian.sol","text":"sol(bsp, b)\n\n\n\n\n\n\n","category":"method"},{"location":"bspline/#SemiLagrangian.sol-Union{Tuple{T}, Tuple{SemiLagrangian.LuSpline{T}, AbstractVector}} where T","page":"B-spline","title":"SemiLagrangian.sol","text":"sol(spA, b)\n\n\n\n\n\n\n","category":"method"},{"location":"bspline/#SemiLagrangian.BSplineFFT","page":"B-spline","title":"SemiLagrangian.BSplineFFT","text":"struct BSplineFFT{T, order} <: SemiLagrangian.BSpline{T, SemiLagrangian.CircEdge, order}\n\nBSplineFFT{T, order} <: AbstractInterpolation{T, CircEdge, order}\nBSplineFFT( order::Int, n::Int, T::DataType=Float64)\n\nType containing spline coefficients for b-spline interpolation based on fft, using the fact that b-spline matrix is a circulant matrix\n\nType parameters\n\nT : the type of data that is interpolate\norder::Int: order of lagrange interpolation\n\nImplementation :\n\nc_fft::Vector{Complex{T}} : fft transform of coefficients\nparfft::PrepareFftBig : fft precomputed data\ntabfct::Vector{Polynomial{T}} : function table for interpolation\n\nArguments :\n\nn : size of the matrix\norder : the order of interpolation\n[T::DataType=Float64] : The type values to interpolate \n\n\n\n\n\n","category":"type"},{"location":"bspline/#SemiLagrangian.sol!-Union{Tuple{T}, Tuple{AbstractVector{T}, BSplineFFT{T}, AbstractVector{T}}} where T","page":"B-spline","title":"SemiLagrangian.sol!","text":"sol!(Y, bsp, b)\n\n\n\n\n\n\n","category":"method"},{"location":"bspline/#SemiLagrangian.sol-Union{Tuple{T}, Tuple{BSplineFFT{T}, AbstractVector{T}}} where T","page":"B-spline","title":"SemiLagrangian.sol","text":"sol(bsp, b)\n\n\n\n\n\n\n","category":"method"},{"location":"hermite/#Hermite","page":"Hermite","title":"Hermite","text":"","category":"section"},{"location":"hermite/","page":"Hermite","title":"Hermite","text":"Modules = [SemiLagrangian]\nOrder   = [:type, :function]\nPages   = [\"hermite.jl\"]","category":"page"},{"location":"hermite/#SemiLagrangian.Hermite","page":"Hermite","title":"SemiLagrangian.Hermite","text":"struct Hermite{T, edge, order} <: AbstractInterpolation{T, edge, order}\n\ntabfct::Array{Polynomials.Polynomial{T}, 1} where T\n\n\n\n\n\n","category":"type"},{"location":"hermite/#SemiLagrangian.PrecalHermite","page":"Hermite","title":"SemiLagrangian.PrecalHermite","text":"struct PrecalHermite{ord, d}\n\nL::Vector{Polynomials.Polynomial{Rational{BigInt}}}\nLprim::Vector{Rational{BigInt}}\nK::Vector{Polynomials.Polynomial{Rational{BigInt}}}\nH::Vector{Polynomials.Polynomial{Rational{BigInt}}}\nbplus::Vector{Rational{BigInt}}\nbminus::Vector{Rational{BigInt}}\nrplus::Int64\nsplus::Int64\nrminus::Int64\nsminus::Int64\n\n\n\n\n\n","category":"type"},{"location":"poisson/#Poisson-solver","page":"Poisson solver","title":"Poisson solver","text":"","category":"section"},{"location":"poisson/","page":"Poisson solver","title":"Poisson solver","text":"Modules = [SemiLagrangian]\nOrder   = [:type, :function]\nPages   = [\"poisson.jl\", \"util_poisson.jl\"]","category":"page"},{"location":"poisson/#SemiLagrangian.PoissonConst","page":"Poisson solver","title":"SemiLagrangian.PoissonConst","text":"struct PoissonConst{T, N, Nsp, Nv, type, typeadd}\n\nPoissonConst{T, Nsp, Nv}\nPoissonConst(adv::Advection{T, Nsp, Nv, Nsum}; isfftbig=true)\n\nConstant data for the computation of poisson coefficients\n\nArguments\n\nadv::Advection{T, Nsp, Nv, Nsum, timeopt} : Advection constant data\nisfftbig=true: if true compute the fttbig structure\n\nImplementation\n\nadv : Advection constant data\n`v_k' : vector of vector of fourier coefficents for integration for each space dimension\nfctv_k : Array of space dimensions of the inverse of the norm of fourier coefficients\npfftbig : Fourier data for space dimensions\n\n\n\n\n\n","category":"type"},{"location":"poisson/#SemiLagrangian.PoissonVar","page":"Poisson solver","title":"SemiLagrangian.PoissonVar","text":"mutable struct PoissonVar{T, N, Nsp, Nv, type, typeadd} <: SemiLagrangian.AbstractExtDataAdv\n\nPoissonVar{T, N, Nsp, Nv} <: AbstractExtDataAdv{T}\nPoissonVar(pc::PoissonConst{T, N, Nsp, Nv})\n\nmutable structure of variable data for the poisson computation\n\nArguments\n\npc::PoissonConst{T, N, Nsp, Nv} : poisson constant data\n\nImplementation\n\npc::PoissonConst{T, Nsp, Nv} : poisson constant data\nrho::Array{T, Nsp} : result of the compute_charge that is the sum along velocity dimensions\nt_elfield::NTuple{Nsp,Array{Complex{T}, Nsp}} : electric fields initialized at each beginning of velocity advection subseries\n\n\n\n\n\n","category":"type"},{"location":"poisson/#SemiLagrangian._get_fctv_k-Union{Tuple{Advection{T, N, timeopt}}, Tuple{timeopt}, Tuple{N}, Tuple{T}} where {T, N, timeopt}","page":"Poisson solver","title":"SemiLagrangian._get_fctv_k","text":"_get_fctv_k(adv)\n\n\n\n\n\n\n","category":"method"},{"location":"poisson/#SemiLagrangian.compute_charge!-Union{Tuple{Nsum}, Tuple{Nv}, Tuple{Nsp}, Tuple{T}, Tuple{Array{T, Nsp}, Tuple{Vararg{UniformMesh{T}, Nv}}, Array{T, Nsum}}} where {T, Nsp, Nv, Nsum}","page":"Poisson solver","title":"SemiLagrangian.compute_charge!","text":"compute_charge!(rho, t_mesh_v, f)\n\n\ncompute_charge!(rho, mesh_v, f)\n\nCompute charge density from phase space distribution f.\n\nρ(x,t) = ∫ f(x,v,t) dv\n\nArguments\n\nrho::Array{T,Nsp}: output result density array.\nt_mesh_v::NTuple{Nv,UniformMesh{T}}: velocity mesh.\nf::Array{T,Nsum}: distribution function array.\n\n\n\n\n\n","category":"method"},{"location":"poisson/#SemiLagrangian.compute_charge!-Union{Tuple{Nv}, Tuple{Nsp}, Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.PoissonVar{T, N, Nsp, Nv}, AdvectionData}} where {T, N, Nsp, Nv}","page":"Poisson solver","title":"SemiLagrangian.compute_charge!","text":"compute_charge!(self, advd)\n\n\ncompute_charge!( self::PoissonVar, advd::AdvectionData)\n\nCompute charge density\n\nρ(x,t) = ∫ f(x,v,t) dv\n\nArgument\n\nself::AdvectionData : mutable structure of variables data.\n\n\n\n\n\n","category":"method"},{"location":"poisson/#SemiLagrangian.compute_ee-Tuple{AdvectionData}","page":"Poisson solver","title":"SemiLagrangian.compute_ee","text":"compute_ee(self)\n\n\ncompute_ee(self::AdvectionData)\n\nCompute electric energy || E(t,.) ||_L2\n\nArgument\n\nself::AdvectionData: advection data structure.\n\n\n\n\n\n","category":"method"},{"location":"poisson/#SemiLagrangian.compute_ee-Union{Tuple{N}, Tuple{T}, Tuple{Tuple{Vararg{UniformMesh{T}, N}}, Tuple{Vararg{Array{T, N}, N}}}} where {T, N}","page":"Poisson solver","title":"SemiLagrangian.compute_ee","text":"compute_ee(t_mesh_sp, t_elf)\n\n\ncompute_ee(t_mesh_sp, t_elf)\n\nCompute electric energy || E(t,.) ||_L2\n\nArguments\n\nt_mesh_sp::NTuple{N,UniformMesh{T}}: space mesh.\nt_elf::NTuple{N,Array{T,N}}: electric field.\n\n\n\n\n\n","category":"method"},{"location":"poisson/#SemiLagrangian.compute_elfield!-Union{Tuple{SemiLagrangian.PoissonVar{T, N, Nsp, Nv}}, Tuple{Nv}, Tuple{Nsp}, Tuple{N}, Tuple{T}} where {T, N, Nsp, Nv}","page":"Poisson solver","title":"SemiLagrangian.compute_elfield!","text":"compute_elfield!(self)\n\n\ncompute_elfield!( self:PoissonVar)\n\ncomputation of electric field     ∇.e = - ρ\n\nArgument\n\nself::PoissonVar : mutable structure of variables data.\n\n\n\n\n\n","category":"method"},{"location":"poisson/#SemiLagrangian.compute_elfield!-Union{Tuple{T}, Tuple{Vector{T}, UniformMesh{T}, Vector{T}}} where T","page":"Poisson solver","title":"SemiLagrangian.compute_elfield!","text":"compute_elfield!(elf, mesh, rho)\n\n\ncompute_elfield!(elf::Array{T,1}, mesh::UniformMesh{T}, rho::Array{T,1}) where{T}\n\nComputation of electric field of one dimension.     ∇.e = - ρ\n\nArgument\n\nelf::Array{T,1}: output Vector.\nmesh::UniformMesh{T} : mesh of the vector\nrho::Array{T,1} : rho computed before\n\n\n\n\n\n","category":"method"},{"location":"poisson/#SemiLagrangian.compute_elfield-Union{Tuple{N}, Tuple{T}, Tuple{Tuple{Vararg{UniformMesh{T}, N}}, Array{T, N}, Any}} where {T<:AbstractFloat, N}","page":"Poisson solver","title":"SemiLagrangian.compute_elfield","text":"compute_elfield(t_mesh_x, rho, pfft)\n\n\n\n\n\n\n","category":"method"},{"location":"poisson/#SemiLagrangian.compute_ke-Union{Tuple{AdvectionData{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Poisson solver","title":"SemiLagrangian.compute_ke","text":"compute_ke(self)\n\n\ncompute_ke(self::AdvectionData)\n\nCompute kinetic Energy.\n\n∫∫ v^2 f(x,v,t) dv dx\n\nArguments\n\nself::AdvectionData: mutable structure of variables data.\n\n\n\n\n\n","category":"method"},{"location":"poisson/#SemiLagrangian.compute_ke-Union{Tuple{Nsum}, Tuple{Nv}, Tuple{Nsp}, Tuple{T}, Tuple{Tuple{Vararg{UniformMesh{T}, Nsp}}, Tuple{Vararg{UniformMesh{T}, Nv}}, Array{T, Nsum}}} where {T, Nsp, Nv, Nsum}","page":"Poisson solver","title":"SemiLagrangian.compute_ke","text":"compute_ke(t_mesh_sp, t_mesh_v, f)\n\n\ncompute_ke(t_mesh_sp, t_mesh_v, f)\n\nCompute kinetic Energy from phase space distribution f.\n\n∫∫ v^2 f(x,v,t) dv dx\n\nArguments\n\nt_mesh_sp::NTuple{Nsp, UniformMesh{T}}: space mesh.\nt_mesh_v::NTuple{Nv, UniformMesh{T}}: velocity mesh.\nf::Array{T,Nsum}: distribution function array.\n\n\n\n\n\n","category":"method"},{"location":"poisson/#SemiLagrangian.getalpha-Union{Tuple{Nv}, Tuple{Nsp}, Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.PoissonVar{T, N, Nsp, Nv, StdPoisson}, AdvectionData{T}, Any}} where {T, N, Nsp, Nv}","page":"Poisson solver","title":"SemiLagrangian.getalpha","text":"getalpha(pv, advd, ind)\n\n\n\n\n\n\n","category":"method"},{"location":"poisson/#SemiLagrangian.getenergy-Tuple{AdvectionData}","page":"Poisson solver","title":"SemiLagrangian.getenergy","text":"getenergy(advd)\n\n\n\n\n\n\n","category":"method"},{"location":"poisson/#SemiLagrangian.getenergyall-Tuple{AdvectionData}","page":"Poisson solver","title":"SemiLagrangian.getenergyall","text":"getenergyall(advd)\n\n\n\n\n\n\n","category":"method"},{"location":"poisson/#SemiLagrangian.getpoissonvar-Tuple{Advection}","page":"Poisson solver","title":"SemiLagrangian.getpoissonvar","text":"getpoissonvar(adv; type, typeadd)\n\n\n\n\n\n\n","category":"method"},{"location":"poisson/#SemiLagrangian.initcoef!-Union{Tuple{Nv}, Tuple{Nsp}, Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.PoissonVar{T, N, Nsp, Nv, StdPoisson}, AdvectionData{T, N}}} where {T, N, Nsp, Nv}","page":"Poisson solver","title":"SemiLagrangian.initcoef!","text":"initcoef!(pv, advd)\n\n\n\n\n\n\n","category":"method"},{"location":"poisson/#SemiLagrangian.initcoef!-Union{Tuple{timeopt}, Tuple{Nv}, Tuple{Nsp}, Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.PoissonVar{T, N, Nsp, Nv, StdPoisson2d}, AdvectionData{T, N, timeopt}}} where {T, N, Nsp, Nv, timeopt}","page":"Poisson solver","title":"SemiLagrangian.initcoef!","text":"initcoef!(pv, advd)\n\n\n\n\n\n\n","category":"method"},{"location":"poisson/#SemiLagrangian.isvelocity-Union{Tuple{Nv}, Tuple{Nsp}, Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.PoissonVar{T, N, Nsp, Nv}, AdvectionData{T, N}}} where {T, N, Nsp, Nv}","page":"Poisson solver","title":"SemiLagrangian.isvelocity","text":"isvelocity(pv, advd)\n\n\ninitcoef!(pv::PoissonVar{T, N,Nsp, Nv}, self::AdvectionData{T, N})\n\nImplementation of the interface function that is called at the begining of each advection     This is implementation for Vlasov-Poisson equation\n\n\n\n\n\n","category":"method"},{"location":"lagrange/#Lagrange-interpolation","page":"Lagrange interpolation","title":"Lagrange interpolation","text":"","category":"section"},{"location":"lagrange/","page":"Lagrange interpolation","title":"Lagrange interpolation","text":"To compute a Lagrange interpolation you have to instantiate a Lagrange type variable:","category":"page"},{"location":"lagrange/","page":"Lagrange interpolation","title":"Lagrange interpolation","text":"Modules = [SemiLagrangian]\nOrder   = [:type, :function]\nPages   = [\"lagrange.jl\"]","category":"page"},{"location":"lagrange/#SemiLagrangian.Lagrange","page":"Lagrange interpolation","title":"SemiLagrangian.Lagrange","text":"struct Lagrange{T, edge, order} <: AbstractInterpolation{T, edge, order}\n\nType containing Lagrange Polynomials coefficients for Lagrange interpolation\n\nType parameters\n\nT : the type of data that is interpolate\nedge::EdgeType : type of edge traitment\norder::Int: order of lagrange interpolation\n\nImplementation :\n\ntabfct::Vector{Polynomial{T}} : vector of all lagrange polynomial, per example the k-th Lagrange polynomial for the designed order is tabfct[k+1]\n\nArguments :\n\norder::Int : the order of interpolation\n[T::DataType=Float64] : The type values to interpolate \n\nKeywords arguments :\n\nedge::EdgeType=CircEdge : type of edge traitment\n\n\n\n\n\n","category":"type"},{"location":"lagrange/#SemiLagrangian._getpolylagrange-Tuple{Int64, Int64, Int64}","page":"Lagrange interpolation","title":"SemiLagrangian._getpolylagrange","text":"_getpolylagrange(k, order, origin)\n\n\nFunction that return the k-th Lagrange Polynomial of a certain order.  If coefficients are rational then the return is exact. The polynomial is equal to :\n\nprod_i=0 i neq k^order fracx - i - origink - i\n\nArguments\n\nk::Int64 : number of the Polynomial, k must be between 0 and order (0<= k <= order).\norder::Int64 : order of the polynomial.\norigin::Int64 : origin of the first indice.\n\nReturns\n\nPolynomial{Rational{BigInt}} : the k-th Lagrange polynomial of order order\n\nThrows\n\nDommaineError : when 0 <= k <= order is false \n\n\n\n\n\n","category":"method"},{"location":"meshes/#Meshes","page":"Meshes","title":"Meshes","text":"","category":"section"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"Modules = [SemiLagrangian]\nOrder   = [:type, :function]\nPages   = [\"mesh.jl\"]","category":"page"},{"location":"meshes/#SemiLagrangian.UniformMesh","page":"Meshes","title":"SemiLagrangian.UniformMesh","text":"struct UniformMesh{T}\n\nUniformMesh{T}\nUniformMesh(start::T, stop::T, length::Int) where {T}\n\n1D uniform mesh data.\n\nArguments\n\nstart::T : beginning of the mesh\nstop::T : end of the mesh\nlength::Int : number of cells of the mesh\n\nImplementation\n\nstep::T  : size step\npoints::Vector{T}: Array with node positions\nwidth::T : Distance between left and right edges.\n\n\n\n\n\n","category":"type"},{"location":"meshes/#Base.length-Tuple{UniformMesh}","page":"Meshes","title":"Base.length","text":"length(mesh)\n\n\nBase.length(mesh::UniformMesh)\n\nGet the length of the mesh\n\nArgument\n\nmesh::UniformMesh : the mesh\n\nReturn\n\nlength : the length of the mesh that is the number of points and cells\n\n\n\n\n\n","category":"method"},{"location":"meshes/#Base.step-Tuple{UniformMesh}","page":"Meshes","title":"Base.step","text":"step(mesh)\n\n\nBase.step(mesh::UniformMesh)\n\nGet the step of the mesh\n\nArgument\n\nmesh::UniformMesh : the mesh\n\nReturn\n\nstep : the step of the mesh that is the difference between two contiguous points\n\n\n\n\n\n","category":"method"},{"location":"meshes/#SemiLagrangian.meshtostd-Union{Tuple{T}, Tuple{UniformMesh{T}, Any}} where T","page":"Meshes","title":"SemiLagrangian.meshtostd","text":"meshtostd(mesh, v)\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#SemiLagrangian.points-Tuple{UniformMesh}","page":"Meshes","title":"SemiLagrangian.points","text":"points(mesh::UniformMesh)\n\nGet the points of the mesh\n\nArgument\n\nmesh::UniformMesh : the mesh\n\nReturn\n\npoints : the points of the mesh that is the vector of all points of the mesh except the last\n\n\n\n\n\n","category":"method"},{"location":"meshes/#SemiLagrangian.start-Tuple{UniformMesh}","page":"Meshes","title":"SemiLagrangian.start","text":"start(mesh)\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#SemiLagrangian.stdtomesh-Union{Tuple{T}, Tuple{UniformMesh{T}, Any}} where T","page":"Meshes","title":"SemiLagrangian.stdtomesh","text":"stdtomesh(mesh, v)\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#SemiLagrangian.stop-Tuple{UniformMesh}","page":"Meshes","title":"SemiLagrangian.stop","text":"stop(mesh)\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#SemiLagrangian.traitmodbegin!-Union{Tuple{N}, Tuple{T}, Tuple{UniformMesh{T}, Array{T, N}}} where {T, N}","page":"Meshes","title":"SemiLagrangian.traitmodbegin!","text":"traitmodbegin!(mesh, f)\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#SemiLagrangian.traitmodbegin!-Union{Tuple{T2}, Tuple{N}, Tuple{T2, Array{T2, N}}} where {N, T2<:Union{Number, OpTuple{N, <:Number}}}","page":"Meshes","title":"SemiLagrangian.traitmodbegin!","text":"traitmodbegin!(lg, f)\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#SemiLagrangian.traitmodend!-Union{Tuple{N}, Tuple{T}, Tuple{UniformMesh{T}, Array{T, N}}} where {T, N}","page":"Meshes","title":"SemiLagrangian.traitmodend!","text":"traitmodend!(mesh, res)\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#SemiLagrangian.traitmodend!-Union{Tuple{T2}, Tuple{N}, Tuple{T2, Array{T2, N}}} where {N, T2<:Union{Number, OpTuple{N, <:Number}}}","page":"Meshes","title":"SemiLagrangian.traitmodend!","text":"traitmodend!(lg, f)\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#SemiLagrangian.vec_k_fft-Union{Tuple{UniformMesh{T}}, Tuple{T}} where T","page":"Meshes","title":"SemiLagrangian.vec_k_fft","text":"vec_k_fft(mesh::UniformMesh{T}) where{T}\n\nGet the fft coefficients of the mesh\n\nArgument\n\nmesh::UniformMesh{T} : the mesh\n\nReturn\n\nfft coefficients\n\n\n\n\n\n","category":"method"},{"location":"meshes/#SemiLagrangian.width-Tuple{UniformMesh}","page":"Meshes","title":"SemiLagrangian.width","text":"width(mesh::UniformMesh)\n\nGet the width of the mesh\n\nArgument\n\nmesh::UniformMesh : the mesh\n\nReturn\n\nwidth : the width that is step*length or distance between left and right edges.\n\n\n\n\n\n","category":"method"},{"location":"extdataadv/#ExtDataAdv","page":"ExtDataAdv","title":"ExtDataAdv","text":"","category":"section"},{"location":"extdataadv/","page":"ExtDataAdv","title":"ExtDataAdv","text":"The AbstractExtDataAdv interface is an interface which allows to define the treatments which will make it possible to obtain the values to be applied to the advections.","category":"page"},{"location":"extdataadv/#Functions-that-needs-to-be-implemented","page":"ExtDataAdv","title":"Functions that needs to be implemented","text":"","category":"section"},{"location":"extdataadv/#Methods-to-define","page":"ExtDataAdv","title":"Methods to define","text":"","category":"section"},{"location":"extdataadv/","page":"ExtDataAdv","title":"ExtDataAdv","text":"initcoef!(parext::AbstractExtDataAdv, self::AdvectionData) : this method called at the beginning of each advection to initialize parext data. The self.parext mutable structure is the only data that initcoef! can modify otherwise it leads to unpredictable behaviour.\ngetalpha(parext::AbstractExtDataAdv, self::AdvectionData, ind) : return the alpha number that is used for interpolation.\ngetperm(parext::AbstractExtDataAdv, advd::AdvectionData) : get the permutation of the dimension as a function of the current state, the dimension where advection occurs must be first, the dimensions used to compute alpha must be at the end.","category":"page"},{"location":"translation/#Translation","page":"Translation","title":"Translation","text":"","category":"section"},{"location":"translation/","page":"Translation","title":"Translation","text":"Modules = [SemiLagrangian]\nOrder   = [:type, :function]\nPages   = [\"translation.jl\"]","category":"page"},{"location":"translation/#SemiLagrangian.TranslationVar","page":"Translation","title":"SemiLagrangian.TranslationVar","text":"mutable struct TranslationVar{T, N} <: SemiLagrangian.AbstractExtDataAdv\n\n\n\n\n\n","category":"type"},{"location":"translation/#SemiLagrangian.getalpha-Union{Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.TranslationVar{T, N}, AdvectionData{T, N}, Any}} where {T, N}","page":"Translation","title":"SemiLagrangian.getalpha","text":"getalpha(pv, self, ind)\n\n\ngetalpha(pv::TranslationVar, self::AdvectionData, i, ind)\n\nImplementation of the interface function that is called before each interpolation in advection\n\n\n\n\n\n","category":"method"},{"location":"translation/#SemiLagrangian.gettranslationvar-Union{Tuple{Tuple{Vararg{T, N}}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Translation","title":"SemiLagrangian.gettranslationvar","text":"gettranslationvar(v)\n\n\n\n\n\n\n","category":"method"},{"location":"translation/#SemiLagrangian.initcoef!-Union{Tuple{N}, Tuple{T}, Tuple{SemiLagrangian.TranslationVar{T, N}, AdvectionData{T, N}}} where {T, N}","page":"Translation","title":"SemiLagrangian.initcoef!","text":"initcoef!(pv, self)\n\n\n\n\n\n\n","category":"method"},{"location":"#SemiLagrangian.jl-Documentation","page":"Home","title":"SemiLagrangian.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let us consider an abstract scalar advection equation of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ \\frac{∂f}{∂t}+ a(x, t) ⋅ ∇f = 0. $","category":"page"},{"location":"","page":"Home","title":"Home","text":"The characteristic curves associated to this equation are the solutions of  the ordinary differential equations","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ \\frac{dX}{dt} = a(X(t), t) $","category":"page"},{"location":"","page":"Home","title":"Home","text":"We shall denote by X(t x s) the unique solution of this equation  associated to the initial condition X(s) = x.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The classical semi-Lagrangian method is based on a backtracking of  characteristics. Two steps are needed to update the distribution function  f^n+1 at t^n+1 from its value f^n at time t^n :","category":"page"},{"location":"","page":"Home","title":"Home","text":"For each grid point x_i compute X(t^n x_i t^n+1) the value  of the characteristic at t^n which takes the value x_i at  t^n+1.\nAs the distribution solution of first equation verifies f^n+1(x_i) = f^n(X(t^n x_i t^n+1)) we obtain the desired value of f^n+1(x_i) by computing  f^n(X(t^nx_it^n+1) by interpolation as X(t^n x_i t^n+1)  is in general not a grid point.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Eric Sonnendrücker - Numerical methods for the Vlasov equations","category":"page"},{"location":"","page":"Home","title":"Home","text":"SemiLagrangian.SemiLagrangian","category":"page"},{"location":"#SemiLagrangian.SemiLagrangian","page":"Home","title":"SemiLagrangian.SemiLagrangian","text":"SemiLagrangian.jl\n\n(Image: Build Status) (Image: ) (Image: codecov)\n\nAdvection implementation in Julia using Semi-Lagrangian numerical method\n\nnote: Note\nThis package is difficult to use directly. There is still a lack of documentation  and some parts like splines need to be optimized. This package has been developed  to calculate the interpolations and advections used in the package  VlasovSolvers.jl.\n\nDependencies\n\nBase\nBase.Threads\nCore\nDocStringExtensions\nFFTW\nLinearAlgebra\nPolynomials\nRequires\n\n\n\n\n\n","category":"module"},{"location":"fft/#FFT","page":"FFT","title":"FFT","text":"","category":"section"},{"location":"fft/","page":"FFT","title":"FFT","text":"Modules = [SemiLagrangian]\nOrder   = [:type, :function]\nPages   = [\"fftbig.jl\"]","category":"page"},{"location":"fft/#SemiLagrangian.PrepareFftBig","page":"FFT","title":"SemiLagrangian.PrepareFftBig","text":"struct PrepareFftBig{T, NUMDIMS, DIMS}\n\nPrepareFftBig( size_fft::Unsigned, [T=BigFloat])\n\nImmutable structure to operate fft transform,  x is the type of non transformed data also called signal.\n\nArguments :\n\nsize_fft::Integer : Number of values, must be a power of two\n[T=BigFloat | x::T ] : type of the values\n\nImplementation\n\nsize_fft : size of the signal\ntab_permut : permutation\nroot_one : size order roots of one\nrootoneconj : conjugate of root_one\n\nstruct parameters\n\nT : type of Float \nNUMDIMS : Numbers of dimensions\nDIMS : tuple of dimensions\n\n\n\n\n\n","category":"type"},{"location":"fft/#SemiLagrangian._reverse_num-Tuple{Any, Any}","page":"FFT","title":"SemiLagrangian._reverse_num","text":"_reverse_num(num, pos)\n\n\nfunction that reverse the order of the pos lowest bits\n\n\n\n\n\n","category":"method"},{"location":"fft/#SemiLagrangian.fftbig!-Union{Tuple{DIMS}, Tuple{NUMDIMS}, Tuple{T}, Tuple{SemiLagrangian.PrepareFftBig{T, NUMDIMS, DIMS}, Any}} where {T, NUMDIMS, DIMS}","page":"FFT","title":"SemiLagrangian.fftbig!","text":"fftbig!(par, signal; flag_inv)\n\n\n\n\n\n\n","category":"method"}]
}
